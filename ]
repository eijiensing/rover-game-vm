use crate::vm::{Immediate, Instruction, Opcode, Register};

pub fn parse_line(line: &str) -> Option<Instruction> {
    let line = line.trim_start();
    let first_word = line
        .chars()
        .take_while(|c| c.is_alphabetic())
        .collect::<String>();
    if first_word.is_empty() {
        return None;
    }

    let operands_string = &line[first_word.len()..].split(",").collect::<Vec<&str>>();

    println!("|{first_word}|");

    let xd = match first_word.as_str() {
        "li" => parse_operands(vec![Operand::Register, Operand::Immediate], operands_string),
        _ => todo!(),
    };

    println!("{xd:?}");

    Some(Instruction {
        energy_cost: 0,
        opcode: Opcode::Addition,
        debug: None,
    })
}

enum Operand {
    Immediate,
    Register,
}

pub fn parse_operands(patterns: Vec<Operand>, parts: &Vec<&str>) -> Option<Vec<ParsedValue>> {
    if patterns.len() != parts.len() {
        return None;
    }

    let mut results = Vec::new();

    for (i, operand) in patterns.iter().enumerate() {
        let part = parts.get(i).unwrap();
        let parsed = match operand {
            Operand::Immediate => parse_immediate(part).map(ParsedValue::Immediate),
            Operand::Register => parse_register(part).map(ParsedValue::Register),
        }?;
        results.push(parsed);
    }

    Some(results)
}

enum ParsedValue {
    Immediate(Immediate),
    Register(Register),
}

pub fn parse_immediate(line: &str) -> Option<Immediate> {
    let line = line.trim_start();
    let number_string = line
        .chars()
        .take_while(|c| c.is_ascii_digit() || c == &'-')
        .collect::<String>();

    if number_string.is_empty() {
        return None;
    }

    let number = number_string.parse::<i32>().unwrap();

    Some(Immediate(number))
}

pub fn parse_register(line: &str) -> Option<Register> {
    let line = line.trim_start();
    println!("line|{line}|");
    let first_word = line
        .chars()
        .take_while(|c| c.is_alphabetic())
        .collect::<String>();
    println!("first_word|{first_word}|");
    if first_word.len() != 1 {
        return None;
    }

    let number_string = line[1..]
        .chars()
        .take_while(|c| c.is_ascii_digit())
        .collect::<String>();

    println!("number_string|{number_string}|");
    if number_string.is_empty() {
        return None;
    }

    let number = number_string.parse::<u8>().unwrap();

    match first_word.as_str() {
        "x" => Some(Register(number)),
        "t" => Some(Register(number)),
        _ => None,
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_parse_line() {
        let result = parse_line("   li t0, -1");
        assert!(result.is_none());
    }
}
